# Default values for nofire-edge.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Image configuration
image:
  repository: nofireai/edge
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

# Image pull secrets
imagePullSecrets: []

# Override name and fullname
nameOverride: ""
fullnameOverride: ""

# Number of replicas
replicaCount: 1

# Deployment strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1

# Service account configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# RBAC configuration
rbac:
  # Specifies whether RBAC resources should be created
  create: true
  # Additional cluster role rules
  extraRules: []

# Pod annotations
podAnnotations: {}

# Pod labels
podLabels: {}

# Pod security context
podSecurityContext:
  {}
  # fsGroup: 2000

# Security context for containers
securityContext:
  {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# Service configuration
service:
  type: ClusterIP
  port: 8080
  targetPort: 8080
  annotations: {}

# Ingress configuration
ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: k8s-resource-graph-client.local
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# Resource limits and requests
resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

# Horizontal Pod Autoscaler
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Topology spread constraints
topologySpreadConstraints: []

# Pod disruption budget
podDisruptionBudget:
  enabled: false
  minAvailable: 1
  # maxUnavailable: 1

# Liveness probe configuration
livenessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Readiness probe configuration
readinessProbe:
  httpGet:
    path: /healthz
    port: http
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Monitoring configuration
monitoring:
  # Enable ServiceMonitor for Prometheus Operator
  serviceMonitor:
    enabled: true
    namespace: ""
    labels:
      release: prometheus
    annotations: {}
    interval: 30s
    path: /metrics
    targetLabels: []
    metricRelabelings: []
    relabelings: []

# Client configuration
config:
  # Logging configuration
  logLevel: "info"
  
  # Server configuration
  serverPort: 8080
   
  maxWorkers: 4
  processInterval: "100ms"
  
  # Graph configuration
  graph:
    pruneInterval: "1h"
    maxPruneAge: "24h"
  
  # Kubernetes configuration
  kube:
    configPath: ""
    resyncInterval: "5m"
    clusterName: "default-cluster"
    resources:
      - "pods"
      - "nodes"
      - "k8services"
      - "configmaps"
      - "secrets"
      - "persistentvolumeclaims"
      - "persistentvolumes"
      - "deployments"
      - "replicasets"
      - "statefulsets"
      - "daemonsets"
      - "jobs"
      - "ingresses" 
      - "namespaces"
      - "services"
  # Causal analysis configuration
  enableCausalAnalysis: false
  causal:
    algorithm: "counterfactual"
    interval: "15m"
  
  # Services configuration
  services:
    nameLabels:
      - "opentelemetry.io/service.name"
      - "app.kubernetes.io/name"
      - "service"
      - "serviceName"
      - "app"
    versionLabels:
      - "opentelemetry.io/service.version"
      - "app.kubernetes.io/version"
      - "version"
    provider: null

  # Publishing configuration
  enablePublishing: true
  publisher:
    # REQUIRED: API key for authentication (must be set to a valid value)
    # apiKey: "your-api-key-here"
    timeout: "30s"
    maxRetries: 3
    retryDelay: "5s"
    enableCompression: true
    graph:
      # REQUIRED: URL for graph data publishing (must be set to a valid URL)
      # url: <brain url>
      interval: "1m"
    heartbeat:
      # url: <brain url>
      interval: "10s"

  # Additional configuration sections (match manifest)
  logging:
    level: "info"
    format: "json"
    output: "stdout"
  
  monitoring:
    prometheusEnabled: true
    metricsPort: 8080
    metricsPath: "/metrics"
  
  tracing:
    enabled: false
    samplingRate: 0.1
    jaegerEndpoint: ""
  
  # Causal analyzers configuration (from manifest)
  causalAnalyzers:
    - type: "counterfactual"
      name: "counterfactual-causality"
      significanceLevel: 0.05
      maxLag: 5
      minConfidenceScore: 0.7
      options:
        stationarizeData: true
        normalizeData: true
    - type: "pc"
      name: "pc-algorithm"
      significanceLevel: 0.05
      maxLag: 5
      minConfidenceScore: 0.7
      options:
        maxConditionSet: 3
  
  # Graph export configuration (from manifest)
  graphExport:
    dot:
      enabled: true
      colorByResourceType: true
      showCausalEdges: true
      rankdir: "LR"
    json:
      enabled: true
      prettyPrint: true

# Environment variables
env: []
# - name: NODE_NAME
#   valueFrom:
#     fieldRef:
#       fieldPath: spec.nodeName

# Additional volumes
extraVolumes: []

# Additional volume mounts
extraVolumeMounts: []

# Extra containers
extraContainers: []

# Init containers
initContainers: []

# Node name configuration (for DaemonSet-like behavior)
nodeName:
  # Enable automatic node name injection
  enabled: true
  # Field path for node name
  fieldPath: "spec.nodeName" 